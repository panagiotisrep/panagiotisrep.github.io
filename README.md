<h1 align="center">   
    GSoC 2019 
</h1>
<br>


<h3>Week 1</h3>

<ul>
    <li>The points in VolEsti are managed by class point.h using std::vectors. I changed the implementation to use Eigen vectors - needed some work at first but will save lot of time later and will be more efficient.</li>
    <li> I implemented the algorithm of "F. Dabbene, P. S. Shcherbakov, and B. T. Polyak. 2010. A Randomized Cutting Plane Method with Probabilistic Geometric Convergence. SIAM J. on Optimization 20, 6 (October 2010), 3185-3207. DOI=http://dx.doi.org/10.1137/080742506", for linear programs.</li>
    <li>I implemented the Phase I barrier method to get an initial feasible point.</li>
    <li>I created tests based on polytopes that could already be generated by VolEsti. Here are links to the <a href="https://www.dropbox.com/sh/4vsl2ix4htkowa4/AABtVR4cX6pRGVeModlsSKHTa?dl=0"  target="_blank">outputs</a> of the tests and to a <a href="https://www.dropbox.com/s/wurmcmt29ae4wss/week1.pdf?dl=0" target="_blank">pdf</a> that summarizes the results.</li>
</ul>

<h3>Week 2</h3>

I decided to keep data on one pdf. From now on, I will update <a  href="https://www.dropbox.com/s/65vrb3828t82ub2/Randomized%20cutting%20plane.pdf?dl=0">this one</a>.

<ul>
    <li>I tried a different random walk, the Hit & Run with coordinate directions. With this new walk and a little of smart programming, I could save lots of computations. There was an impressive speed up!</li>
    <li>I implemented a heuristic for choosing a better direction vector (implicit isotropization).</li>
</ul>

<h3>Week 3</h3>

<ul>
    <li>The team had a good idea! Let's try sampling a single point at each phase and cut the polytope based on that.</li>
    <li>I tried different stopping criteria for the algorithm (this was bugging me since first week). A weak criterion may cause us to lose a good solution, while a strong one may lead to excessive computations.</li>
    <li>The random walk stucks and can't escape from edges. We need some escaping steps. An idea is, to try to walk towards the center of the Chebyshev ball.</li>
</ul>

<h3>Week 4</h3>

<ul>
    <li>There is still work on the escape step, at which we try to move towards the Chebyshev center. Needs testing and if it works I can make it work a bit faster.</li>
    <li>Another idea for an escape step is the billiard walk. It works fine. The advantage of the work till now, is that it scales very well with the dimension of the polytope (testing it on problems, which lpsolve needs hours to solve!). Must test to see which escape step works better and when, because they appear to be a bottleneck, so I must use them rarely.</li>
        
</ul>

<h3>Week 5</h3>

<ul>
    <li>Further experimentation with the billiard walk. Tried to combinethe billiard walk with the direction produced by trying to reach the Chebyshev center.</li>
    <li>Tested to see how the algorithm performs in many dimensions (up to 1500).</li>
</ul>

<h3>Week 6</h3>

<ul>
    <li>Read about LMIs and semidefinite programming</li>
    <li>Started working on the boundary oracle for Spectrahedra</li>
</ul>

<h3>Week 7</h3>

<ul>
    <li>Started Implementing the boundary oracle for Spectrahedra.</li>
    <li>Tried various ways to make the required computations, to achieve better stability.</li>
</ul>

<h3>Week 8</h3>

<ul>
    <li>Continued working for the bounadry oracle for Spectrahedra.</li>
    <li>Implement randomized cutting plane algorithm for SDP.</li>
    <li>Implement the sampled vovariance matrix heuristic for SDP.</li>
</ul>

<h3>Week 9</h3>

<ul>
    <li>Continue debugging the randomized cutting plane algorithm for SDP.</li>
    <li>Support for SDPA format</li>
    <li>Create SDP tests in SDPA format.</li>
</ul>

<h3>Week 10</h3>

<ul>
    <li>Continued testing the randomized cutting plane algorithm for SDP.</li>
    <li>Started reading the paper for the simulated annealing algorithm.</li>
    <li>Need to find how to sample from a segment w.r.t. Boltzmann distribution.</li>
</ul>


<h3>Week 11</h3>

<ul>
    <li>Implemented the simulated annealing algorithm for LP.</li>
    <li>Searching / implementing for various heuristics.</li>
</ul>
